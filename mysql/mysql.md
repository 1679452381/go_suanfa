# mysql

## SQL 分类
* DDL 数据定义语言 
  * CREATE
  * DROP
  * ALERT
* DML 数据操作语言
  * INSERT
  * DELETE
  * UPDATE
  * SELECT
* DCL 数据控制语言 
  * GRANT
  * REVOKE
  * COMMIT
  * ROLLBACK
  * SAVEPOINT 

## 14 视图
### 数据库对象
* 表
* 数据字典
* 约束 
  * 执行数据校验的规则，用于保证数据完整性的规则
* 视图
 * 一个或多个数据表里的数据的逻辑显示，视图并不存储数据
* 索引
  * 提高查取性能
* 存储过程
* 存储函数
* 触发器
  * 事件监听器，当数据发生特定事件后，触发器被触发，完成相应处理

### 视图
#### 1.为什么使用视图
视图使用的是表的一部分，针对不同的用户展示不同的数据

#### 2.视图的理解
* 视图是虚拟表，占内存小
* 视图建立在数据表的基础上，此时数据表叫做基表
* 视图不保存数据，但对视图中数据进行增删改查操作时，对应数据表中的数据也会发生变化
#### 3. 视图的使用 
* 创建视图
```sql
-- 查询语句中的字段别名会作为视图中字段的名称出现
CREATE VIEW 视图名称[(字段列表)] AS 查询语句 

-- 视图中的字段不是表中的字段时，要给字段起个别名
```
```sql
--利用视图对数据进行格式化
CREATE VIEW emp_depart
AS
SELECT CONCAT(last_name,"(",department_name,")") AS emp_dept
FROM employees e JOIN department d 
WHERE e.depart  ment_id = d.deparment_id
```
* 基于视图创建视图
```sql
CREATE VIEW  emp 
AS
SELECT employee_id,last_name
FROM vu_empl 
```
* 查看视图
```sql
-- 查看数据库 表对象 视图对象
SHOW TABLES

-- 查看视图结构
DESCRIBE 视图名称
    
-- 查看视图属性信息
SHOW TABLE STATUS LIKE '视图名称' \G
    
-- 查看视图的详细定义信息
SHOW CREATE VIEW '视图名称'
```
#### 4.不可更新的视图
只有视图中的字段和基表中的字段一一对应的时候,才能对视图进行更新或者删除操作

**注意**
视图一般用来查询数据

#### 5.修改视图
```sql
CREATE [OR REPALCE ] VIEW 视图名称[(字段列表)] AS 查询语句

ALERT VIEW 视图名称 AS 查询语句
```
#### 6.删除视图
```sql
DROP VIEW 视图名称
```
#### 7.总结
* 优点
  * 操作简单
  * 减少数据冗余
  * 数据安全
  * 适应灵活多变的需求
  * 能够分解复杂的查询逻辑
* 不足
  * 实际数据结构发生变化,我们要对试图进行维护,如果视图含有复杂逻辑,会造成难以维护问题

## 15 存储过程与存储函数
### 1 存储过程
 - - -
#### 1.1 理解
* 思想:一组经过**预先编译**的SQL语句的封装
* 执行过程：存储过程预先存储在MySQL服务器上，需要执行的时候，客户端只需要向服务端发送命令，服务器端
就可以把预先存储好的一系列SQL语句全部执行
* 优点
  * 简化操作，提高SQL语句的复用性
  * 减少操作中的失误，提高效率
  * 减少网络传输量（客户端不需要把所有的SQL语句通过网络发给服务器）
  * 减少SQL语句暴露的风险，提高安全性
* 和视图，存储函数的不同
  * 视图是虚拟表，不对底层数据直接操作，存储过程直接操作底层数据，能够处理一些发杂的逻辑
  * 和函数一样可以直接调用，但相比较于函数 没有返回值
#### 1.2分类
存储过程的参数可以是IN，OUT，和INOUT 
* 没有参数
* 仅带IN类型
* 仅带OUT类型
* 即带IN又带OUT
* 带INOUT
### 2 创建存储过程
- - - 
#### 2.1 语法
```sql
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型, ...)
[characteristics...]
BEGIN 
    存储过程体
END
```
### 3 存储函数
-- -
#### 3.1 语法分析
```sql
CREATE FUNCTION 函数名(参数名 参数类型,...)
RETURNS 返回值类型
[characteristics...]
BEGIN 
 函数体 函数体中包含RETURN 语句
END
```
#### 3.2 调用存储函数
```sql
SELECT 函数名(参数列表)
```

#### 3.3 存储过程  存储函数查看
* 查看创建信息
```sql
SHOW CREATE [ PROCEDURE | FUNCTION ] 存储过程/存储函数名
```
* 查看状态信息
```sql
SHOW  [ PROCEDURE | FUNCTION ]  STATUS
SHOW  [ PROCEDURE | FUNCTION ]  STATUS  LIKE 存储过程/存储函数名
```

## 索引
-- -
### 1.为什么使用索引
索引是存储引擎用于快速找到数据记录的一种数据结构。建索引减少磁盘的i/o次数
### 2.索引及其优缺点
索引是帮助MySQL高效获取数据的数据结构

索引是在存储引擎中实现的，存储引擎的不一样，支持的索引类型也不一样，存储引擎定义了每个表的
**最大索引数**和**最大索引长度**，所有存储引擎支持每个表至少有16个索引，总索引长度至少为
256个字节

#### 2.1 优点
* 提高数据检索效率，降低数据库I/O成本
* 通过创建唯一索引，保证数据唯一性
* 在实现数据的完整性方面，可以 **加速表与表之间的连接**。即对于有联合关系的子表和父表联合查询时，提高查询速度
* 使用分组和排序子句进行数据查询时，可以显著减少查询中分子和排序的时间，降低CPU的消耗
#### 2.2 缺点
* 创建索引和维护索引要消耗时间，随着数据量的增加，耗费时间也会增加
* 索引占用磁盘空间
  * 降低更新表的速率，对表中数据进行增删改查时，索引也要动态维护，降低了数据的维护速度

### 3. InnoDB中索引的推演
 - - -
#### 3.1 索引之前的查找
```sql
SELECT  [列表名称] FROM 表名 WHERE 列名 == xxx
```
#### 3.2 设计索引
数据页 目录页

**你的表能放1000 0000 0000 条记录吗？？** 一般情况下 B+树不会超过4层，我们通过主键值去查找
某条记录最多只需要做4个页面查找（3个目录项页查找和一个用户记录页查找），又因为每个页面中
有**页目录**，所以页内也可以使用**二分查找**，树的层次越低，系统IO次数越少

#### 3.3 常见索引
-- -
##### 3.3.1 聚簇索引
聚簇索引并不是一种单独的索引类型，而是**一种数据存储方式**（所有用户记录都存储在叶子节点），也就是所谓的**索引及数据，数据集索引**.
  * **特点**
    * 使用记录主键值的大小进行记录和页的排序
      * 页内记录是按照主键大小顺序排成一个**单链表**
      * 各个存放**用户记录的页**也是根据用户记录的主键的大小顺序排成的**双向链表**
      * 存放**目录项记录的页**分为不同的层次，在同一层次中的页根据目录项记录的主键大小顺序排成**双向链表** 
    * B+树的叶子节点存储的是完整的用户记录
  * 优点
    * 访问数据快，因为聚簇索引将索引和数据放在一个B+树中
    * 聚簇索引对于主键的**排序查找**和**范围查找**速度非常快
    * 按照聚簇索引排序的顺序，查询显示一定范围的数据时，由于数据紧密相连，**节省了大量的IO操作**
  * 缺点
    * 插入速度严重依赖插入顺序
    * 更新主键代价大
    * 二级索引访问需要两次索引查找，第一次找到主键，第二根据逐渐找到数据
  * 限制
    * MySQL数据库中InnoDB数据引擎支持聚簇索引，MySAM不支持聚簇索引。
    * 由于数据物理存储排序方式只有一种，所以MySQL**表只能有一个聚簇索引**，一般情况下是表的主键
    * 如果没有主键 InnoDB会选择**非空的唯一索引代替**，如果没有这样的索引，InnoDB会隐式的定义一个主键作为聚簇索引
    * 为了充分利用聚簇索引的聚簇的特性，InnoDB表的主键尽量**选择有顺序的id**。
  


这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句创建，InnoDB存储引擎**自动**为我们创建聚簇索引 

##### 3.3.2 非聚簇索引（二级索引或辅助索引）
使用聚簇索引只能搜索条件是**主键值**才能发挥作用，如果我们想用别的列作为搜索条件该怎么办？

答：多建几个B+树，不同的B+树采用不同的排序规则

* 二级索引和聚簇索引的不同:
  * 使用记录c2列的大小进行记录和页的排序
  * B+树的叶子节点存储的不是完整的用户记录，而只有c2列和主键两个值
  * 目录项记录的是c2列和页号的搭配
* 使用二级索引的查找过程
  * 查找二级索引的目录项记录页，**确定目录项记录页**
  * 通过目录项记录页 确定**用户记录页**
  * 查找数据在用户记录页的具体位置
  * 拿到主键，根据主键通过聚簇索引查找完整的用户记录

**概念：回表**
从二级索引拿到主键，再用主键通过聚簇索引查找完整的用户记录的过程叫做回表。

**问：为什么需要回表**

**答：** 如果把完整的记录存储在叶子节点就不用回表，但是这相当于把所有的用户记录又copy了一份，**太浪费存储空间了**。

非聚簇索引的存在不影响数据在聚簇索引中的存储，所以一张表可以有多个非聚簇索引。

##### 3.3.3 联合索引
可以按照多个数值排列，比如按照c2,c3排列
* 先把各个记录和页按照c2列排列
* 在记录c2列相同的情况下，采用c3列进行排列

#### 3.4 InnoDB的B+树注意事项
-- -
##### 3.4.1 根页面位置万年不动
* 数据库索引的根页面包含整棵索引树的入口,如果其位置变动,那么访问这个索引树的过程将变得非常困难和低效;
* 数据库系统通过索引根页面的物理地址快速定位到整棵索引树,如果这个地址变动,那么系统需要重复扫描找到新的地址,造成大量无意义IO和资源浪费;
* 索引分裂或页面溢出时,只会产生新的非根页面,根页面仍然不变
* 数据库系统维护的系统目录中保存着每个索引的根页面地址,这使得系统可以快速定位任意一个索引。
##### 3.4.2 内节点（非叶子节点）中目录项记录的唯一性
##### 3.4.3 一个页面最少存储两条内容






















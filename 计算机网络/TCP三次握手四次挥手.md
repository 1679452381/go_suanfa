
Tcp
* 传输控制协议
* 面向连接
* 基于字节流
* 可靠
* 采用三次握手建立连接
* 采用四次挥手断开连接


### 1. TCP 三次握手过程

* ACK -确认，使得确认号有效
* RST -重置连接
* SYN -用于初始化一个连续的序列号
* FIN - 该报文的发送方已结束向对方发送数据

#### 为什么要三次握手 

* 第一次握手：客户端向服务端发送建立连接网络包 ，服务端收到后得出：客户端发送能力正常，服务端接受能力正常
* 第二次握手：服务端向客户端发送网络包，客户端收到后得出： 客户端的发送，接收能力正常，服务端的发送，接受能力正常
* 第三次握手：客户端向服务端发送确认建立连接网络包，服务
端收到后得出：客户端的发送，接收能力正常，服务端的发送，接受能力正常

最少经过三次握手，才能让双方都确认对方和自己的接受和发送能力正常，才能建立连接。
#### 为什么要四次挥手

TCP连接时双向传输模式，客户端和服务端都可以发送或者接受数据，当一方要关闭是，会发送一个指令告知对方，这是对方会回复一个ACK，
此时一个方向的连接关闭了，但另一个方向仍然可以发送数据，等到所有的数据发送完成后，会发送一个FIN段来关闭连接，接收方发送ACK确认关闭连接。

* 三次握手过程
  * 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c)
  * 服务端发送自己的SYN段作为应答,同样致命自己的ISN(s),为了确认客户端的SYN，将ISN(c)+1作为ACK值，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。
  * 为了确认服务端的SYN，将ISN(s)+1作为ACK发送给服务端
* 四次握手过程
  * 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。
  * 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。
  * 服务端发起自己的FIN段，ACK=K+1, Seq=L
  * 客户端确认。ACK=L+1

#### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还
能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

### 2. 为什么是三次握手，不能是两次握手呢
### 3. TCP 四次挥手过程 
### 4. 为什么通常不能是三次挥手？也能三次挥手吗？为什么